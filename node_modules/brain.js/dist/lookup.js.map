{"version":3,"sources":["../src/lookup.js"],"names":["lookup","hashes","hash","reduce","memo","Object","assign","toHash","objects2D","table","valueIndex","i","length","objects","j","object","p","hasOwnProperty","data","tableIndex","dataIndex","input","output","index","arrayLength","result","Float32Array","from","push","toArray","array","offset","limit","z","shape","Array","isArray","buffer","ArrayBuffer","Error","value","keys"],"mappings":"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","file":"lookup.js","sourcesContent":["/* Functions for turning sparse hashes into arrays and vice versa */\nexport default class lookup {\n  /**\n   * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`\n   * @param {Object} hashes\n   * @returns {Object}\n   */\n  static toTable(hashes) {\n    const hash = hashes.reduce((memo, hash) => {\n      return Object.assign(memo, hash);\n    }, {});\n\n    return lookup.toHash(hash);\n  }\n\n  /**\n   * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`\n   * @param {Object} objects2D\n   * @returns {Object}\n   */\n  static toTable2D(objects2D) {\n    const table = {};\n    let valueIndex = 0;\n    for (let i = 0; i < objects2D.length; i++) {\n      const objects = objects2D[i];\n      for (let j = 0; j < objects.length; j++) {\n        const object = objects[j];\n        for (const p in object) {\n          if (object.hasOwnProperty(p) && !table.hasOwnProperty(p)) {\n            table[p] = valueIndex++;\n          }\n        }\n      }\n    }\n    return table;\n  }\n\n  static toInputTable(data) {\n    const table = {};\n    let tableIndex = 0;\n    for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {\n      for (let p in data[dataIndex].input) {\n        if (!table.hasOwnProperty(p)) {\n          table[p] = tableIndex++;\n        }\n      }\n    }\n    return table;\n  }\n\n  static toInputTable2D(data) {\n    const table = {};\n    let tableIndex = 0;\n    for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {\n      const input = data[dataIndex].input;\n      for (let i = 0; i < input.length; i++) {\n        const object = input[i];\n        for (let p in object) {\n          if (!table.hasOwnProperty(p)) {\n            table[p] = tableIndex++;\n          }\n        }\n      }\n    }\n    return table;\n  }\n\n  static toOutputTable(data) {\n    const table = {};\n    let tableIndex = 0;\n    for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {\n      for (let p in data[dataIndex].output) {\n        if (!table.hasOwnProperty(p)) {\n          table[p] = tableIndex++;\n        }\n      }\n    }\n    return table;\n  }\n\n  static toOutputTable2D(data) {\n    const table = {};\n    let tableIndex = 0;\n    for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {\n      const output = data[dataIndex].output;\n      for (let i = 0; i < output.length; i++) {\n        const object = output[i];\n        for (let p in object) {\n          if (!table.hasOwnProperty(p)) {\n            table[p] = tableIndex++;\n          }\n        }\n      }\n    }\n    return table;\n  }\n\n  /**\n   * performs `{a: 6, b: 7} -> {a: 0, b: 1}`\n   * @param {Object} hash\n   * @returns {Object}\n   */\n  static toHash(hash) {\n    let lookup = {};\n    let index = 0;\n    for (let i in hash) {\n      lookup[i] = index++;\n    }\n    return lookup;\n  }\n\n  /**\n   * performs `{a: 0, b: 1}, {a: 6} -> [6, 0]`\n   * @param {*} lookup\n   * @param {*} object\n   * @param {*} arrayLength\n   * @returns {Float32Array}\n   */\n  static toArray(lookup, object, arrayLength) {\n    const result = new Float32Array(arrayLength);\n    for (let p in lookup) {\n      result[lookup[p]] = object.hasOwnProperty(p) ? object[p] : 0;\n    }\n    return result;\n  }\n\n  static toArrayShort(lookup, object) {\n    const result = [];\n    for (let p in lookup) {\n      if (!object.hasOwnProperty(p)) break;\n      result[lookup[p]] = object[p];\n    }\n    return Float32Array.from(result);\n  }\n\n  static toArrays(lookup, objects, arrayLength) {\n    const result = [];\n    for (let i = 0; i < objects.length; i++) {\n      result.push(this.toArray(lookup, objects[i], arrayLength));\n    }\n    return result;\n  }\n\n  /**\n   * performs `{a: 0, b: 1}, [6, 7] -> {a: 6, b: 7}`\n   * @param {Object} lookup\n   * @param {Array} array\n   * @returns {Object}\n   */\n  static toObject(lookup, array) {\n    const object = {};\n    for (let p in lookup) {\n      object[p] = array[lookup[p]];\n    }\n    return object;\n  }\n\n  static toObjectPartial(lookup, array, offset = 0, limit = 0) {\n    const object = {};\n    let i = 0;\n    for (let p in lookup) {\n      if (offset > 0) {\n        if (i++ < offset) continue;\n      }\n      if (limit > 0) {\n        if (i++ >= limit) continue;\n      }\n      object[p] = array[lookup[p] - offset];\n    }\n    return object;\n  }\n\n  /**\n   *\n   * @param {Array} array\n   * @returns {*}\n   */\n  static lookupFromArray(array) {\n    let lookup = {};\n    let z = 0;\n    let i = array.length;\n    while (i-- > 0) {\n      lookup[array[i]] = z++;\n    }\n    return lookup;\n  }\n\n  static dataShape(data) {\n    const shape = [];\n\n    if (data.input) {\n      shape.push('datum');\n      data = data.input;\n    } else if (Array.isArray(data)) {\n      if (data[0].input) {\n        shape.push('array', 'datum');\n        data = data[0].input;\n      } else {\n        shape.push('array');\n        data = data[0];\n      }\n    }\n\n    let p;\n    while (data) {\n      for (p in data) { break; }\n      if (!data.hasOwnProperty(p)) break;\n      if (Array.isArray(data) || data.buffer instanceof ArrayBuffer) {\n        shape.push('array');\n        data = data[p];\n      } else if (typeof data === 'object') {\n        shape.push('object');\n        data = data[p];\n      } else {\n        throw new Error('unhandled signature');\n      }\n    }\n    shape.push(typeof data);\n    return shape;\n  }\n\n  static addKeys(value, table) {\n    if (Array.isArray(value)) return;\n    table = table || {};\n    let i = Object.keys(table).length;\n    for (const p in value) {\n      if (!value.hasOwnProperty(p)) continue;\n      if (table.hasOwnProperty(p)) continue;\n      table[p] = i++;\n    }\n    return table;\n  }\n}\n"]}