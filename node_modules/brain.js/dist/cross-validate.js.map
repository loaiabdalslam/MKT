{"version":3,"sources":["../src/cross-validate.js"],"names":["CrossValidate","Classifier","options","json","trainOpts","trainSet","testSet","classifier","beginTrain","Date","now","trainingStats","train","beginTest","testStats","test","endTest","stats","Object","assign","trainTime","testTime","iterations","error","total","learningRate","hiddenLayers","network","toJSON","array","i","length","j","Math","floor","random","temp","data","k","Error","size","constructor","Array","shuffleArray","newData","keys","forEach","key","avgs","binaryStats","truePos","trueNeg","falsePos","falseNeg","results","stat","isBinary","dclone","slice","splice","result","testPartition","hasOwnProperty","push","precision","recall","accuracy","testSize","trainSize","sets","fromJSON","crossValidateJson","reduce","prev","cur","Infinity","instance"],"mappings":"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","file":"cross-validate.js","sourcesContent":["export default class CrossValidate {\n\n  /**\n   *\n   * @param {NeuralNetwork|constructor} Classifier\n   * @param {object} [options]\n   */\n  constructor(Classifier, options) {\n    this.Classifier = Classifier;\n    this.options = options;\n    this.json = null;\n  }\n\n  /**\n   *\n   * @param {object} trainOpts\n   * @param {object} trainSet\n   * @param {object} testSet\n   * @returns {void|*}\n   */\n  testPartition(trainOpts, trainSet, testSet) {\n    const classifier = new this.Classifier(this.options);\n    const beginTrain = Date.now();\n    const trainingStats = classifier.train(trainSet, trainOpts);\n    const beginTest = Date.now();\n    const testStats = classifier.test(testSet);\n    const endTest = Date.now();\n    const stats = Object.assign({}, testStats, {\n      trainTime: beginTest - beginTrain,\n      testTime: endTest - beginTest,\n      iterations: trainingStats.iterations,\n      error: trainingStats.error,\n      total: testStats.total,\n      learningRate: classifier.trainOpts.learningRate,\n      hiddenLayers: classifier.hiddenLayers,\n      network: classifier.toJSON()\n    });\n\n    return stats;\n  }\n\n  /**\n   * Randomize array element order in-place.\n   * Using Durstenfeld shuffle algorithm.\n   * source: http://stackoverflow.com/a/12646864/1324039\n   */\n  shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n      let j = Math.floor(Math.random() * (i + 1));\n      let temp = array[i];\n      array[i] = array[j];\n      array[j] = temp;\n    }\n    return array;\n  }\n\n  /**\n   *\n   * @param {object} data\n   * @param {object} trainOpts\n   * @param {number} [k]\n   * @returns {\n   *  {\n   *    avgs: {\n   *      error: number,\n   *      trainTime: number,\n   *      testTime: number,\n   *      iterations: number,\n   *      error: number\n   *    },\n   *    stats: {\n   *      truePos: number,\n   *      trueNeg: number,\n   *      falsePos: number,\n   *      falseNeg: number,\n   *      total: number\n   *    },\n   *    sets: Array\n   *  }\n   * }\n   */\n  train(data, trainOpts = {}, k = 4) {\n    if (data.length < k) {\n      throw new Error(`Training set size is too small for ${ data.length } k folds of ${ k }`);\n    }\n\n    const size = data.length / k;\n\n    if (data.constructor === Array) {\n      this.shuffleArray(data);\n    } else {\n      const newData = {};\n      this.shuffleArray(Object.keys(data)).forEach((key) => {\n        newData[key] = data[key];\n      });\n      data = newData;\n    }\n\n    const avgs = {\n      trainTime: 0,\n      testTime: 0,\n      iterations: 0,\n      error: 0\n    };\n\n    const stats = {\n      total: 0\n    };\n\n    const binaryStats = {\n      total: 0,\n      truePos: 0,\n      trueNeg: 0,\n      falsePos: 0,\n      falseNeg: 0\n    };\n\n    const results = [];\n    let stat;\n    let isBinary = null;\n\n    for (let i = 0; i < k; i++) {\n      const dclone = data.slice(0);\n      const testSet = dclone.splice(i * size, size);\n      const trainSet = dclone;\n      const result = this.testPartition(trainOpts, trainSet, testSet);\n\n      if (isBinary === null) {\n        isBinary =\n          result.hasOwnProperty('falseNeg')\n          && result.hasOwnProperty('falsePos')\n          && result.hasOwnProperty('trueNeg')\n          && result.hasOwnProperty('truePos');\n        if (isBinary) {\n          Object.assign(stats, binaryStats);\n        }\n      }\n\n      for (stat in avgs) {\n        if (stat in avgs) {\n          avgs[stat] += result[stat];\n        }\n      }\n\n      for (stat in stats) {\n        if (stat in stats) {\n          stats[stat] += result[stat];\n        }\n      }\n\n      results.push(result);\n    }\n\n    for (stat in avgs) {\n      if (stat in avgs) {\n        avgs[stat] /= k;\n      }\n    }\n\n    if (isBinary) {\n      stats.precision = stats.truePos / (stats.truePos + stats.falsePos);\n      stats.recall = stats.truePos / (stats.truePos + stats.falseNeg);\n      stats.accuracy = (stats.trueNeg + stats.truePos) / stats.total;\n    }\n\n    stats.testSize = size;\n    stats.trainSize = data.length - size;\n\n\n    return this.json = {\n      avgs: avgs,\n      stats: stats,\n      sets: results\n    };\n  }\n\n  toNeuralNetwork() {\n    return this.fromJSON(this.json);\n  }\n\n  toJSON() {\n    return this.json;\n  }\n\n  fromJSON(crossValidateJson) {\n    const Classifier = this.Classifier;\n    const json = crossValidateJson.sets.reduce((prev, cur) => prev.error < cur.error ? prev : cur, {error: Infinity}).network;\n    if (Classifier.fromJSON) {\n      return Classifier.fromJSON(json);\n    }\n    const instance = new Classifier();\n    instance.fromJSON(json);\n    return instance;\n  }\n}\n"]}