{"version":3,"sources":["../src/neural-network-gpu.js"],"names":["NeuralNetworkGPU","options","forwardPropagate","backwardPropagate","changesPropagate","biasesPropagate","biasCopies","copyBias","changesCopies","copyChanges","weightsCopies","copyWeights","errorCheckInterval","gpu","GPU","mode","buildRunInput","buildCalculateDeltas","buildGetChanges","buildChangeBiases","buildGetMSE","value","logErrorRate","runInput","input","calculateDeltas","output","adjustWeights","getMSE","errors","outputLayer","getChanges","changeBiases","weightedSum","activation","weightedSumSigmoid","weightedSumRelu","weightedSumLeakyRelu","weightedSumTanh","Error","layer","createKernel","sizes","outputToTexture","hardcodeConstants","constants","size","texturizeInputData","thread","x","outputImmutable","outputs","weights","biases","calcDeltas","calcDeltasSigmoid","calcDeltasRelu","calcDeltasLeakyRelu","calcDeltasTanh","createKernelMap","error","alias","calcErrorOutput","deltas","targets","calcError","nextWeights","nextDeltas","length","target","addWeights","changes","calcChanges","previousOutputs","change","learningRate","trainOpts","momentum","y","hardCodeConstants","addBiases","mse","isRunnable","inputLookup","lookup","toArray","inputLookupLength","inputTexture","outputTextures","outputLookup","toObject","data","updateTrainingOptions","formatData","endTime","Date","now","timeout","status","iterations","verifyIsInitialized","texturizeOutputData","map","set","Array","from","NeuralNetwork","prototype","toJSON","call","getTrainOptsJSON","inputs","sum","k","Math","exp","tanh","previousChanges","i","pow"],"mappings":"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","file":"neural-network-gpu.js","sourcesContent":["import NeuralNetwork from './neural-network';\nimport lookup from './lookup';\nimport GPU from 'gpu.js';\n\n/**\n *\n * @param {object} options\n * @constructor\n */\nexport default class NeuralNetworkGPU extends NeuralNetwork {\n  constructor(options = {}) {\n    super(options);\n    this.forwardPropagate = [];\n    this.backwardPropagate = [];\n    this.changesPropagate = [];\n    this.biasesPropagate = [];\n    this.biasCopies = [];\n    this.copyBias = [];\n    this.changesCopies = [];\n    this.copyChanges = [];\n    this.weightsCopies = [];\n    this.copyWeights = [];\n    this.errorCheckInterval = 100;\n    this.gpu = new GPU({mode: options.mode});\n  }\n\n  /**\n   *\n   */\n  initialize() {\n    super.initialize();\n    this.buildRunInput();\n    this.buildCalculateDeltas();\n    this.buildGetChanges();\n    this.buildChangeBiases();\n    this.buildGetMSE();\n  }\n\n  setActivation() {}\n\n  /**\n   *\n   * @param value\n   * @param logErrorRate\n   */\n  trainPattern(value, logErrorRate) {\n    // forward propagate\n    this.runInput(value.input);\n\n    // back propagate\n    this.calculateDeltas(value.output);\n    this.adjustWeights();\n\n    if (logErrorRate) {\n      return this.getMSE(this.errors[this.outputLayer])[0];\n    } else {\n      return null;\n    }\n  }\n\n  adjustWeights() {\n    this.getChanges();\n    this.changeBiases();\n  }\n\n  buildRunInput() {\n    let weightedSum = null;\n\n    switch (this.activation) {\n      case 'sigmoid':\n        weightedSum = weightedSumSigmoid;\n        break;\n      case 'relu':\n        weightedSum = weightedSumRelu;\n        break;\n      case 'leaky-relu':\n        weightedSum = weightedSumLeakyRelu;\n        break;\n      case 'tanh':\n        weightedSum = weightedSumTanh;\n        break;\n      default:\n        throw new Error('unknown activation ' + this.activation);\n    }\n\n    for(let layer = 1; layer <= this.outputLayer; layer++){\n      this.forwardPropagate[layer] = this.gpu.createKernel(weightedSum, {\n        output: [this.sizes[layer]],\n        outputToTexture: true,\n        hardcodeConstants: true,\n        constants: {\n          size: this.sizes[layer - 1]\n        }\n      });\n    }\n\n    this.texturizeInputData = this.gpu.createKernel(function(value) {\n      return value[this.thread.x];\n    }, {\n      output: [this.sizes[1]],\n      outputToTexture: true,\n      hardcodeConstants: true,\n      outputImmutable: true\n    });\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  runInput(input) {\n    let output;\n    this.outputs[0] = input;\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      this.outputs[layer] = this.forwardPropagate[layer](\n        this.weights[layer],\n        this.biases[layer],\n        input\n      );\n      output = input = this.outputs[layer];\n    }\n    return output;\n  }\n\n  buildCalculateDeltas() {\n    let calcDeltas = null;\n\n    switch (this.activation) {\n      case 'sigmoid':\n        calcDeltas = calcDeltasSigmoid;\n        break;\n      case 'relu':\n        calcDeltas = calcDeltasRelu;\n        break;\n      case 'leaky-relu':\n        calcDeltas = calcDeltasLeakyRelu;\n        break;\n      case 'tanh':\n        calcDeltas = calcDeltasTanh;\n        break;\n      default:\n        throw new Error('unknown activation ' + this.activation);\n    }\n\n    for (let layer = this.outputLayer; layer > 0; layer--) {\n      if (layer === this.outputLayer) {\n        this.backwardPropagate[layer] = this.gpu.createKernelMap({\n            error: GPU.alias('calcErrorOutput', calcErrorOutput),\n            deltas: GPU.alias('calcDeltas', calcDeltas)\n          }, function(outputs, targets) {\n            const output = outputs[this.thread.x];\n            return calcDeltas(calcErrorOutput(output, targets), output);\n          }, {\n            output: [this.sizes[layer]],\n            outputToTexture: true,\n            hardcodeConstants: true\n          });\n      } else {\n        this.backwardPropagate[layer] = this.gpu.createKernelMap({\n            error: GPU.alias('calcError', calcError),\n            deltas: GPU.alias('calcDeltas', calcDeltas),\n          }, function(nextWeights, outputs, nextDeltas){\n            let output = outputs[this.thread.x];\n            return calcDeltas(calcError(nextWeights, nextDeltas), output);\n          }, {\n            output: [this.sizes[layer]],\n            outputToTexture: true,\n            hardcodeConstants: true,\n            constants: {\n              size: this.deltas[layer + 1].length\n            }\n          });\n      }\n    }\n  }\n\n  calculateDeltas(target) {\n    for (let layer = this.outputLayer; layer > 0; layer--) {\n      let output;\n\n      if (layer === this.outputLayer) {\n        output = this.backwardPropagate[layer](\n          this.outputs[layer],\n          target);\n      } else {\n        output = this.backwardPropagate[layer](\n          this.weights[layer + 1],\n          this.outputs[layer],\n          this.deltas[layer + 1],\n        );\n      }\n\n      this.deltas[layer] = output.deltas;\n      this.errors[layer] = output.error;\n    }\n  }\n\n  buildGetChanges() {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      this.changesPropagate[layer] = this.gpu.createKernelMap({\n          weights: GPU.alias('addWeights', addWeights),\n          changes: GPU.alias('calcChanges', calcChanges)\n        },\n        function(previousOutputs, deltas, weights, changes) {\n          let change = calcChanges(\n            changes,\n            deltas,\n            previousOutputs);\n\n            return addWeights(change, weights);\n        }, {\n          output: [this.sizes[layer - 1], this.sizes[layer]],\n          outputToTexture: true,\n          hardcodeConstants: true,\n          constants:{\n            size: this.outputs[layer - 1].length,\n            learningRate: this.trainOpts.learningRate,\n            momentum: this.trainOpts.momentum\n          }\n        });\n\n      this.copyChanges[layer] = this.gpu.createKernel(function(value) {\n        return value[this.thread.y][this.thread.x];\n      }, {\n        output: this.changesPropagate[layer].output,\n        outputToTexture: true,\n        hardCodeConstants: true\n      });\n\n      this.copyWeights[layer] = this.gpu.createKernel(function(value) {\n        return value[this.thread.y][this.thread.x];\n      }, {\n        output: this.changesPropagate[layer].output,\n        outputToTexture: true,\n        hardCodeConstants: true\n      });\n    }\n  }\n\n  getChanges() {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      let output = this.changesPropagate[layer](\n        this.outputs[layer - 1],\n        this.deltas[layer],\n        this.weightsCopies[layer] || this.weights[layer],\n        this.changesCopies[layer] || this.changes[layer]\n      );\n      this.changes[layer] = output.changes;\n      this.weights[layer] = output.weights;\n\n      this.changesCopies[layer] = this.copyChanges[layer](output.changes);\n      this.weightsCopies[layer] = this.copyWeights[layer](output.weights);\n    }\n  }\n\n  buildChangeBiases() {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      this.biasesPropagate[layer] = this.gpu.createKernel(addBiases, {\n        output: [this.sizes[layer]],\n        outputToTexture: true,\n        hardcodeConstants: true,\n        constants: {\n          learningRate: this.trainOpts.learningRate\n        }\n      });\n      this.copyBias[layer] = this.gpu.createKernel(function(value) {\n        return value[this.thread.x];\n      }, {\n        output: this.biasesPropagate[layer].output,\n        outputToTexture: true,\n        hardCodeConstants: true\n      });\n    }\n  }\n\n  changeBiases() {\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      this.biases[layer] = this.biasesPropagate[layer](\n        this.biasCopies[layer] || this.biases[layer],\n        this.deltas[layer]\n      );\n      this.biasCopies[layer] = this.copyBias[layer](this.biases[layer]);\n    }\n  }\n\n  buildGetMSE() {\n    this.getMSE = this.gpu.createKernel(mse, {\n      output: [1],\n      hardcodeConstants: true,\n      constants: {\n        size: this.sizes[this.outputLayer]\n      }\n    });\n  }\n\n  /**\n   *\n   * @param input\n   * @returns {*}\n   */\n  run(input) {\n    if (!this.isRunnable) return null;\n    if (this.inputLookup) {\n      input = lookup.toArray(this.inputLookup, input, this.inputLookupLength);\n    }\n    const inputTexture = this.texturizeInputData(input);\n    const outputTextures = this.runInput(inputTexture);\n    let output;\n    if (outputTextures.toArray) {\n      output = outputTextures.toArray(this.gpu);\n    } else {\n      output = outputTextures;\n    }\n\n    if (this.outputLookup) {\n      output = lookup.toObject(this.outputLookup, output);\n    }\n    return output;\n  }\n\n  /**\n   *\n   * @param data\n   * @param options\n   * @protected\n   * @return { data, status, endTime }\n   */\n  prepTraining(data, options) {\n    this.updateTrainingOptions(options);\n    data = this.formatData(data);\n    const endTime = Date.now() + this.trainOpts.timeout;\n\n    const status = {\n      error: 1,\n      iterations: 0\n    };\n\n    this.verifyIsInitialized(data);\n\n    const texturizeOutputData = this.gpu.createKernel(function(value) {\n      return value[this.thread.x];\n    }, {\n      output: [data[0].output.length],\n      outputToTexture: true,\n      hardcodeConstants: true,\n      outputImmutable: true\n    });\n\n    return {\n      data: data.map((set) => {\n        return {\n          input: this.texturizeInputData(set.input),\n          output: texturizeOutputData(set.output)\n        }\n      }),\n      status,\n      endTime\n    };\n  }\n\n  toJSON() {\n    if (!this.weights[1].toArray) {\n      // in fallback mode\n      return super.toJSON();\n    }\n\n    // in GPU mode\n    const weights = [];\n    const biases = [];\n    for (let layer = 1; layer <= this.outputLayer; layer++) {\n      weights[layer] = Array.from(this.weights[layer].toArray(this.gpu));\n      biases[layer] = Array.from(this.biases[layer].toArray(this.gpu));\n    }\n\n    // pseudo lo-fi decorator\n    return NeuralNetwork.prototype.toJSON.call({\n      inputLookup: this.inputLookup,\n      outputLookup: this.outputLookup,\n      outputLayer: this.outputLayer,\n      sizes: this.sizes,\n      getTrainOptsJSON: () => this.getTrainOptsJSON(),\n      weights,\n      biases,\n    });\n  }\n}\n\nfunction weightedSumSigmoid(weights, biases, inputs) {\n  let sum = biases[this.thread.x];\n  for (let k = 0; k < this.constants.size; k++) {\n    sum += weights[this.thread.x][k] * inputs[k];\n  }\n  //sigmoid\n  return 1 / (1 + Math.exp(-sum));\n}\n\nfunction weightedSumRelu(weights, biases, inputs) {\n  let sum = biases[this.thread.x];\n  for (let k = 0; k < this.constants.size; k++) {\n    sum += weights[this.thread.x][k] * inputs[k];\n  }\n  //relu\n  return (sum < 0 ? 0 : sum);\n}\n\nfunction weightedSumLeakyRelu(weights, biases, inputs) {\n  let sum = biases[this.thread.x];\n  for (let k = 0; k < this.constants.size; k++) {\n    sum += weights[this.thread.x][k] * inputs[k];\n  }\n  //leaky relu\n  return (sum < 0 ? 0 : 0.01 * sum);\n}\n\nfunction weightedSumTanh(weights, biases, inputs) {\n  let sum = biases[this.thread.x];\n  for (let k = 0; k < this.constants.size; k++) {\n    sum += weights[this.thread.x][k] * inputs[k];\n  }\n  //tanh\n  return Math.tanh(sum);\n}\n\nfunction calcErrorOutput(output, targets) {\n  return targets[this.thread.x] - output;\n}\n\nfunction calcDeltasSigmoid(error, output) {\n  //sigmoid derivative\n  return error * output * (1 - output);\n}\n\nfunction calcDeltasRelu(error, output) {\n  //relu derivative\n  return output > 0 ? error : 0;\n}\n\nfunction calcDeltasLeakyRelu(error, output) {\n  //leaky relu derivative\n  return output > 0 ? error : 0.01 * error;\n}\n\nfunction calcDeltasTanh(error, output) {\n  //tanh derivative\n  return (1 - output * output) * error;\n}\n\nfunction calcError(nextWeights, nextDeltas){\n  let error = 0;\n  for(let k = 0; k < this.constants.size; k++){\n    error += nextDeltas[k] * nextWeights[k][this.thread.x];\n  }\n  return error;\n}\n\nfunction calcChanges(\n  previousChanges,\n  deltas,\n  previousOutputs\n) {\n  return (this.constants.learningRate * deltas[this.thread.y] * previousOutputs[this.thread.x])\n      + (this.constants.momentum * previousChanges[this.thread.y][this.thread.x]);\n}\n\nfunction addWeights(change, weights){\n  return change + weights[this.thread.y][this.thread.x];\n}\n\nfunction addBiases(biases, deltas){\n  return biases[this.thread.x] + (deltas[this.thread.x] * this.constants.learningRate);\n}\n\n// mean squared error, reimplemented for GPU\nfunction mse(errors) {\n  let sum = 0;\n  for (let i = 0; i < this.constants.size; i++) {\n    sum += Math.pow(errors[i], 2);\n  }\n  return sum / this.constants.size;\n}\n"]}