{"version":3,"sources":["../src/train-stream.js"],"names":["TrainStream","options","objectMode","neuralNetwork","Error","dataFormatDetermined","i","size","count","sum","floodCallback","doneTrainingCallback","updateTrainingOptions","trainOpts","iterations","errorThresh","log","logPeriod","callbackPeriod","callback","on","finishStreamIteration","bind","write","chunk","enc","next","emit","addFormat","firstDatum","data","formatData","trainPattern","verifyIsInitialized","error","Writable"],"mappings":"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","file":"train-stream.js","sourcesContent":["import { Writable } from 'stream';\n\n/**\n *\n * @param opts\n * @returns {TrainStream}\n * @constructor\n */\nexport default class TrainStream extends Writable {\n  constructor(options) {\n    super({\n      objectMode: true\n    });\n\n    options = options || {};\n\n    // require the neuralNetwork\n    if (!options.neuralNetwork) {\n      throw new Error('no neural network specified');\n    }\n\n    const { neuralNetwork } = options;\n    this.neuralNetwork = neuralNetwork;\n    this.dataFormatDetermined = false;\n    this.i = 0; // keep track of internal iterations\n    this.size = 0;\n    this.count = 0;\n    this.sum = 0;\n    this.floodCallback = options.floodCallback;\n    this.doneTrainingCallback = options.doneTrainingCallback;\n\n    // inherit trainOpts settings from neuralNetwork\n    neuralNetwork.updateTrainingOptions(options);\n    const { trainOpts } = neuralNetwork;\n    this.iterations = trainOpts.iterations;\n    this.errorThresh = trainOpts.errorThresh;\n    this.log = trainOpts.log;\n    this.logPeriod = trainOpts.logPeriod;\n    this.callbackPeriod = trainOpts.callbackPeriod;\n    this.callback = trainOpts.callback;\n\n    this.on('finish', this.finishStreamIteration.bind(this));\n  }\n\n  endInputs() {\n    this.write(false);\n  }\n\n  /**\n   * _write expects data to be in the form of a datum. ie. {input: {a: 1 b: 0}, output: {z: 0}}\n   * @param chunk\n   * @param enc\n   * @param next\n   * @returns {*}\n   * @private\n   */\n  _write(chunk, enc, next) {\n    if (!chunk) {\n      // check for the end of one iteration of the stream\n      this.emit('finish');\n      return next();\n    }\n\n    if (!this.dataFormatDetermined) {\n      this.size++;\n      this.neuralNetwork.addFormat(chunk);\n      this.firstDatum = this.firstDatum || chunk;\n      return next();\n    }\n\n    this.count++;\n\n    const data = this.neuralNetwork.formatData(chunk);\n    this.sum += this.neuralNetwork.trainPattern(data[0], true);\n\n    // tell the Readable Stream that we are ready for more data\n    next();\n  }\n\n  /**\n   *\n   * @returns {*}\n   */\n  finishStreamIteration() {\n    if (this.dataFormatDetermined && this.size !== this.count) {\n      this.log('This iteration\\'s data length was different from the first.');\n    }\n\n    if (!this.dataFormatDetermined) {\n      const data = this.neuralNetwork.formatData(this.firstDatum);\n      this.neuralNetwork.verifyIsInitialized(data);\n      this.dataFormatDetermined = true;\n\n      if (typeof this.floodCallback === 'function') {\n        this.floodCallback();\n      }\n      return;\n    }\n\n    const error = this.sum / this.size;\n\n    if (this.log && (this.i % this.logPeriod === 0)) {\n      this.log(`iterations: ${ this.i}, training error: ${ error }`);\n    }\n    if (this.callback && (this.i % this.callbackPeriod === 0)) {\n      this.callback({\n        error: error,\n        iterations: this.i\n      });\n    }\n\n    this.sum = 0;\n    this.count = 0;\n    // update the iterations\n    this.i++;\n\n    // do a check here to see if we need the stream again\n    if (this.i < this.iterations && error > this.errorThresh) {\n      if (typeof this.floodCallback === 'function') {\n        return this.floodCallback();\n      }\n    } else {\n      // done training\n      if (typeof this.doneTrainingCallback === 'function') {\n        return this.doneTrainingCallback({\n          error: error,\n          iterations: this.i\n        });\n      }\n    }\n  }\n}\n"]}